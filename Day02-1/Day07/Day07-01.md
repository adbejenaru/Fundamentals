Metodele în Java reprezintă un concept fundamental care ne permite să grupăm un set de instrucțiuni sub un singur nume pentru a le putea reutiliza și organiza mai bine codul. Ele oferă o modalitate de a împărți codul în blocuri mai mici, ușor de înțeles și gestionat.

### De ce folosim metode?
1. **Reutilizare:** Dacă o parte din cod este utilizată de mai multe ori, putem pune acel cod într-o metodă și îl putem apela ori de câte ori avem nevoie.
2. **Organizare:** Împărțirea codului în bucăți logice îl face mai ușor de înțeles și menținut.
3. **Întreținere mai ușoară:** Dacă trebuie să modificăm comportamentul unei funcționalități, putem face modificarea doar în metoda respectivă, fără a căuta toate locurile în care este utilizată.

### Definirea unei metode
O metodă este definită prin specificarea tipului de valoare returnată, a numelui metodei și a unei liste de parametri (opțional). Sintaxa generală este următoarea:

```java
<tip returnat> <nume metodă>(<listă de argumente opționale>) {
    // Corpul metodei
}
```

- **Tip returnat:** Indică ce tip de date va returna metoda după ce își încheie execuția. Dacă metoda nu returnează nimic, folosim `void`.
- **Nume metodă:** Numele metodei trebuie să fie sugestiv, astfel încât să reflecte acțiunea pe care o face metoda.
- **Listă de argumente:** Metodele pot primi unul sau mai mulți parametri (sau chiar niciunul). Aceștia sunt utilizați pentru a furniza date metodei.

### Exemplu simplu de metodă
```java
void afiseazaNume(String nume) {
    System.out.println("Numele meu este: " + nume);
}
```
În acest exemplu, metoda `afiseazaNume` primește un parametru de tip `String` și afișează numele primit ca argument.

### Argumentele unei metode
Metodele pot accepta orice număr de argumente de orice tip. Dacă o metodă conține mai mulți parametri, aceștia trebuie separați prin virgulă.

#### Exemplu cu mai multe argumente:
```java
int calculeazaDiferenta(int numar1, int numar2) {
    return numar1 - numar2;
}
```
Această metodă primește doi parametri de tip `int` și returnează diferența dintre aceștia.

### Valoarea returnată
O metodă poate returna o valoare folosind cuvântul cheie `return`. Tipul valorii returnate trebuie să fie compatibil cu tipul de date specificat în definiția metodei.

#### Exemplu de metodă care returnează o valoare:
```java
int intoarceNumar() {
    return 42;
}
```
În acest exemplu, metoda `intoarceNumar` returnează valoarea 42.

### Valoarea returnată `void`
Dacă o metodă nu returnează nicio valoare, folosim `void` ca tip de returnare. În acest caz, metoda doar execută un set de instrucțiuni fără a da o valoare înapoi.

#### Exemplu de metodă `void`:
```java
void afiseazaMesaj() {
    System.out.println("Salutare, lume!");
}
```
Această metodă afișează un mesaj, dar nu returnează nicio valoare.

### Întreruperea anticipată a unei metode `void`
Chiar și metodele care nu returnează nimic (`void`) pot fi întrerupte înainte de terminarea lor folosind cuvântul cheie `return` fără a specifica o valoare.

#### Exemplu:
```java
void verificaNumar(int numar) {
    if (numar % 2 == 0) {
        return;  // Metoda se oprește dacă numărul este par
    }
    System.out.println("Numărul este impar: " + numar);
}
```
Dacă numărul primit este par, metoda se oprește. Dacă este impar, afișează mesajul corespunzător.

### Corpul metodei
Corpul metodei este între acoladele `{}` și conține toate instrucțiunile care trebuie executate atunci când metoda este apelată.

#### Exemplu:
```java
int inmulteste(int numar1, int numar2) {
    return numar1 * numar2;
}
```
În acest exemplu, corpul metodei conține o singură instrucțiune, care returnează produsul celor două numere.

### Apelarea metodei
Pentru a apela o metodă, trebuie să o invocăm folosind numele ei și, dacă este necesar, să îi furnizăm argumentele corespunzătoare.

#### Exemplu:
```java
int rezultat = inmulteste(5, 3);  // Apelare metodă cu argumente
System.out.println("Rezultatul este: " + rezultat);
```
Metoda `inmulteste` este apelată cu valorile `5` și `3`, iar rezultatul este afișat.

### Convenția de denumire a metodelor
În Java, este o convenție ca numele metodelor să fie scrise folosind **camelCase**, adică prima literă a numelui metodei este minusculă, iar fiecare cuvânt următor începe cu majusculă.

#### Exemple de nume de metode corecte:
- `afiseazaMesaj`
- `calculeazaSuma`
- `obtineValoareMaxima`

### Rezumat despre metode:

| Componentă       | Explicație                                                                 |
|------------------|----------------------------------------------------------------------------|
| **Tip returnat**  | Tipul de date pe care îl returnează metoda (`int`, `void`, `String`, etc.) |
| **Nume metodă**   | Numele metodei, folosit pentru a o apela                                  |
| **Argumente**     | Parametri opționali care sunt furnizați metodei                           |
| **Corpul metodei**| Instrucțiunile pe care metoda le execută între acolade `{}`               |

### Exemplu complet:
```java
public class ExempluMetode {
    
    // Metodă statică ce calculează produsul a trei numere
    public static int inmulteste(int a, int b, int c) {
        return a * b * c;
    }
    
    // Metodă statică ce afișează un mesaj
    public static void afiseazaMesaj(String mesaj) {
        System.out.println(mesaj);
    }

    public static void main(String[] args) {
        // Apelăm metoda inmulteste
        int rezultat = inmulteste(2, 3, 4);
        System.out.println("Rezultatul înmulțirii: " + rezultat); // Output: Rezultatul înmulțirii: 24

        // Apelăm metoda afiseazaMesaj
        afiseazaMesaj("Aceasta este o metodă în Java!"); // Output: Aceasta este o metodă în Java!
    }
}
```

În acest exemplu, metoda `inmulteste` primește trei argumente și returnează produsul lor. Metoda `afiseazaMesaj` primește un `String` și îl afișează pe ecran.


Sigur! Iată câteva alte exemple care demonstrează utilizarea metodelor în Java în contexte diferite.





### 2. **Metodă care numără vocalele dintr-un șir de caractere**
Aceasta este o metodă care primește un `String` și returnează numărul de vocale din acel șir.

```java
public class ExempluNumarVocale {
    // Metodă care numără vocalele dintr-un șir de caractere
    public static int numaraVocale(String text) {
        int count = 0;
        text = text.toLowerCase();
        for (int i = 0; i < text.length(); i++) {
            char c = text.charAt(i);
            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {
                count++;
            }
        }
        return count;
    }

    public static void main(String[] args) {
        String text = "Salutare!";  // Definim un șir de caractere
        int numarVocale = numaraVocale(text);  // Apelăm metoda
        System.out.println("Numărul de vocale este: " + numarVocale);  // Output: Numărul de vocale este: 4
    }
}
```

### 5. **Metodă care convertește minute în ore și minute**
Această metodă primește un număr de minute și returnează echivalentul în ore și minute.

```java
public class ExempluConversieTimp {
    // Metodă care convertește minute în ore și minute
    public static void convertesteTimp(int minute) {
        int ore = minute / 60;
        int minuteRamase = minute % 60;
        System.out.println(minute + " minute este echivalent cu " + ore + " ore și " + minuteRamase + " minute.");
    }

    public static void main(String[] args) {
        int minute = 130;  // Definim un număr de minute
        convertesteTimp(minute);  // Apelăm metoda
        // Output: 130 minute este echivalent cu 2 ore și 10 minute.
    }
}
```

Expresia `return an % 400 == 0;` apare în cadrul unei metode care verifică dacă un an este **bisect** și face parte din logica necesară pentru a determina acest lucru conform regulilor de calcul ale anului bisect.

### Regula pentru anul bisect

Un **an bisect** este un an care:
1. Este divizibil cu 4.
2. Dacă este divizibil cu 100, atunci trebuie să fie **și divizibil cu 400** pentru a fi considerat bisect.

Deci, logica completă este:
- Un an este bisect dacă este **divizibil cu 4**, **dar nu** este divizibil cu 100, **cu excepția** cazului în care este divizibil și cu **400**. 

### De ce `return an % 400 == 0;`?

În contextul metodei de verificare a anului bisect, regula pentru un an divizibil cu 100 este că acesta nu este bisect decât dacă este și divizibil cu 400. Astfel, dacă anul este divizibil cu 100 (de exemplu, 1700, 1800, 1900), verificăm mai departe dacă este divizibil cu 400. 

Doar anii care îndeplinesc condiția `an % 400 == 0` vor fi considerați ani bisecți (de exemplu, 1600 și 2000).

### Explicație detaliată a codului:

Iată un exemplu complet care ilustrează regula anului bisect:

```java
public class AnBisect {
    public static boolean esteAnBisect(int an) {
        if (an % 4 == 0) {  // Verificăm dacă anul este divizibil cu 4
            if (an % 100 == 0) {  // Dacă este divizibil cu 100...
                return an % 400 == 0;  // ... trebuie să fie și divizibil cu 400 pentru a fi bisect
            } else {
                return true;  // Dacă nu este divizibil cu 100, este bisect
            }
        }
        return false;  // Dacă nu este divizibil cu 4, nu este bisect
    }

    public static void main(String[] args) {
        int an1 = 2000;
        int an2 = 1900;
        System.out.println(an1 + " este bisect: " + esteAnBisect(an1));  // Output: 2000 este bisect: true
        System.out.println(an2 + " este bisect: " + esteAnBisect(an2));  // Output: 1900 este bisect: false
    }
}
```

### Explicația fiecărei părți a codului:
1. **`an % 4 == 0`**: Dacă anul este divizibil cu 4, atunci ar putea fi un an bisect.
2. **`an % 100 == 0`**: Dacă anul este divizibil cu 100, verificăm o condiție suplimentară.
3. **`an % 400 == 0`**: Dacă anul este divizibil cu 400, anul este considerat bisect, chiar dacă este divizibil cu 100. În caz contrar (dacă este divizibil doar cu 100 și nu cu 400), nu este bisect.

Astfel, `return an % 400 == 0;` se asigură că, pentru un an divizibil cu 100, doar cei care sunt divizibili și cu 400 vor fi bisecți.


